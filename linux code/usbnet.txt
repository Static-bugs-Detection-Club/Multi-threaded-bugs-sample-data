static void smsc95xx_unbind(struct usbnet *dev, struct usb_interface *intf)
{
	struct smsc95xx_priv *pdata = (struct smsc95xx_priv *)(dev->data[0]);

	if (pdata) {
		cancel_delayed_work_sync(&pdata->carrier_check);
		netif_dbg(dev, ifdown, dev->net, "free pdata\n");
		kfree(pdata);
		pdata = NULL;
		dev->data[0] = 0;
	}
}
static u32 smsc_crc(const u8 *buffer, size_t len, int filter)
{
	u32 crc = bitrev16(crc16(0xFFFF, buffer, len));
	return crc << ((filter % 2) * 16);
}
static int smsc95xx_enable_phy_wakeup_interrupts(struct usbnet *dev, u16 mask)
{
	struct mii_if_info *mii = &dev->mii;
	int ret;
	netdev_dbg(dev->net, "enabling PHY wakeup interrupts\n");
	/* read to clear */
	ret = smsc95xx_mdio_read_nopm(dev->net, mii->phy_id, PHY_INT_SRC);
	if (ret < 0)
		return ret;
	/* enable interrupt source */
	ret = smsc95xx_mdio_read_nopm(dev->net, mii->phy_id, PHY_INT_MASK);
	if (ret < 0)
		return ret;
	ret |= mask;
	smsc95xx_mdio_write_nopm(dev->net, mii->phy_id, PHY_INT_MASK, ret);
	return 0;
}
static int smsc95xx_link_ok_nopm(struct usbnet *dev)
{
	struct mii_if_info *mii = &dev->mii;
	int ret;
	/* first, a dummy read, needed to latch some MII phys */
	ret = smsc95xx_mdio_read_nopm(dev->net, mii->phy_id, MII_BMSR);
	if (ret < 0)
		return ret;
	ret = smsc95xx_mdio_read_nopm(dev->net, mii->phy_id, MII_BMSR);
	if (ret < 0)
		return ret;
	return !!(ret & BMSR_LSTATUS);
}